////////////////////////////////////////////////////////////////////
// A continuous MDP for the classical mountain car control
// problem. A car is placed at the bottom of a valley, and must be
// brought to a destination located at the top of a hill by pushing
// the car left and right. 
// 
// This domain originated in Andrew Moore's 1990 PhD thesis found here.
// However, to illustrate the object-oriented power of RDDL, the 
// domain is modified so that the terrain is piecewise-linear, rather
// than the continuous sinusoidal function in the original version. 
//
// References:
// 
// 		Moore, Andrew William. Efficient memory-based learning for robot
// 		control. No. UCAM-CL-TR-209. University of Cambridge, Computer 
// 		Laboratory, 1990.
// 
// Author(s): 
//		Mike Gimelfarb (mgimelfarb@yahoo.ca)
//
////////////////////////////////////////////////////////////////////
domain mountain_car {

    requirements = {
        reward-deterministic
    };
	
	// piecewise linear slopes
	types {
		segment : object;
	};
	
    pvariables {

    	// physics constants
		GRAVITY-MAG : { non-fluent, real, default = 0.0025 };       // force of gravity acting down
		FORCE-MAG 	: { non-fluent, real, default = 0.0015 };	    // force applied to the side of the cart

		// valley shape defined by piecewise linear with x in [-1.2, 0.6] and y in [0, 1]
		X-START(segment) : { non-fluent, real, default = -1.2 };    // starting x-position of segment
		Y-START(segment) : { non-fluent, real, default = 0 };       // starting y-position of segment
		X-END(segment)   : { non-fluent, real, default = 0.6 };     // ending x-position of segment
		Y-END(segment)   : { non-fluent, real, default = 0 };	    // ending y-position of segment
		
		// bounds
		MIN-POS  : { non-fluent, real, default = -1.2 };            // min position of cart
		MAX-POS  : { non-fluent, real, default = 0.6 };			    // max position of cart
		MAX-VEL  : { non-fluent, real, default = 0.07 };            // max velocity of cart
		GOAL-MIN : { non-fluent, real, default = 0.5 };	            // desired x position of cart
		VEL-MIN  : { non-fluent, real, default = 0.0 };             // desired velocity of the cart
		
		// reward const
		GOAL-REWARD : { non-fluent, real, default = 100.0 };        // goal reward
		ACTION-PENALTY : { non-fluent, real, default = 0.1 };       // action penalty multiplier for reward function
		
		// interm fluents
		in-segment(segment) : { interm-fluent, bool };              // is the cart currently in this segment
		pos-slope           : { interm-fluent, real };              // slope of current line segment
		
		// states
       	pos    	: { state-fluent, real, default = -0.5 };          	// cart position
       	vel   	: { state-fluent, real, default = 0 };              // cart velocity

       	// actions
       	action : { action-fluent, real, default = 0 };              // whether to accelerate left (-1) or right (1)
    };

    cpfs {
		
	    // get the slope of the segment the cart is currently in
	    in-segment(?p) = (pos >= X-START(?p)) ^ (pos < X-END(?p));
	    pos-slope = ( sum_{?p : segment} [ ((Y-END(?p) - Y-START(?p)) / (X-END(?p) - X-START(?p))) * in-segment(?p) ] );
		
	    // update the position of the cart
	    pos' = max[min[pos + vel, MAX-POS], MIN-POS];
		
	    // update the velocity of the cart				
	    vel' = [ max[min[vel + action * FORCE-MAG + (-GRAVITY-MAG) * pos-slope, MAX-VEL], -MAX-VEL] ];
    };

    // R = 100 only when the cart reaches the goal and the velocity is higher than the desired velocity
	reward = (if((pos' >= GOAL-MIN) ^ (vel' >= VEL-MIN)) then GOAL-REWARD else 0.0)
	          - (ACTION-PENALTY * pow[action, 2]);
		
	termination {
		(pos >= GOAL-MIN) ^ (vel >= VEL-MIN);
	};
	
    state-invariants {
	
		// check that state is within bounds
		pos >= MIN-POS;
		pos <= MAX-POS;
		vel >= -MAX-VEL;
		vel <= MAX-VEL;
		
		// system is physically plausible
		GRAVITY-MAG >= 0 ^ FORCE-MAG >= 0;
		MAX-POS >= MIN-POS ^ MAX-VEL >= 0;
		
		// segments are valid
		forall_{?p : segment} [X-START(?p) >= MIN-POS ^ X-START(?p) <= MAX-POS];
		forall_{?p : segment} [X-END(?p) >= MIN-POS ^ X-END(?p) <= MAX-POS];
		forall_{?p : segment} [X-END(?p) > X-START(?p)];
		
		forall_{?p : segment} [Y-START(?p) >= 0 ^ Y-START(?p) <= 1];
		forall_{?p : segment} [Y-END(?p) >= 0 ^ Y-END(?p) <= 1];
    };

    action-preconditions {
        action >= -1;
        action <= 1;
    };

}
